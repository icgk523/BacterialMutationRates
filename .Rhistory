for (lambda_starting in search_lambdas) {
brownian_model <- tryCatch({    # Try corBrownian
gls(Wattersons_Corrected_Overall_Rate ~ gene_data, data = reordered_subset_data, correlation = corBrownian(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
brownian_null_model <- tryCatch({    # Try null model with corBrownian
gls(Wattersons_Corrected_Overall_Rate ~ 1, data = reordered_subset_data, correlation = corBrownian(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
if (!is.null(brownian_model)) {
brownian_AIC <- AIC(brownian_model)
brownian_p_value <- coef(summary(brownian_model))[8]
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "brownian", AIC = brownian_AIC, p_value = brownian_p_value, stringsAsFactors = FALSE))
}
if (!is.null(brownian_null_model)) {
brownian_null_AIC <- AIC(brownian_null_model)
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "brownian_null", AIC = brownian_null_AIC, p_value = NA, stringsAsFactors = FALSE))
break
}
}
for (lambda_starting in search_lambdas) {
martins_model <- tryCatch({    # Try corMartins
gls(Wattersons_Corrected_Overall_Rate ~ gene_data, data = reordered_subset_data, correlation = corMartins(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
martins_null_model <- tryCatch({    # Try null model with corMartins
gls(Wattersons_Corrected_Overall_Rate ~ 1, data = reordered_subset_data, correlation = corMartins(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
if (!is.null(martins_model)) {
martins_AIC <- AIC(martins_model)
martins_p_value <- coef(summary(martins_model))[8]
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "martins", AIC = martins_AIC, p_value = martins_p_value, stringsAsFactors = FALSE))
}
if (!is.null(martins_null_model)) {
martins_null_AIC <- AIC(martins_null_model)
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "martins_null", AIC = martins_null_AIC, p_value = NA, stringsAsFactors = FALSE))
break
}
}
for (lambda_starting in search_lambdas) {
grafen_model <- tryCatch({    # Try corGrafen
gls(Wattersons_Corrected_Overall_Rate ~ gene_data, data = reordered_subset_data, correlation = corGrafen(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
grafen_null_model <- tryCatch({    # Try null model with corGrafen
gls(Wattersons_Corrected_Overall_Rate ~ 1, data = reordered_subset_data, correlation = corGrafen(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
if (!is.null(grafen_model)) {
grafen_AIC <- AIC(grafen_model)
grafen_p_value <- coef(summary(grafen_model))[8]
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "grafen", AIC = grafen_AIC, p_value = grafen_p_value, stringsAsFactors = FALSE))
}
if (!is.null(grafen_null_model)) {
grafen_null_AIC <- AIC(grafen_null_model)
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "grafen_null", AIC = grafen_null_AIC, p_value = NA, stringsAsFactors = FALSE))
break
}
}
}
View(results_watterson)
#### Watterson's Analysis ####
subset_data <- complete_data %>% filter(Wattersons_Corrected_Overall_Rate != "#DIV/0!") %>% mutate(Log_Wattersons_Corrected_Overall_Rate = log10(Wattersons_Corrected_Overall_Rate)) # Keep only Watterson's data which has values
Wattersons_Corrected_Overall_Rate
log10(complete_data$Wattersons_Corrected_Overall_Rate)
log10(as.numeric(complete_data$Wattersons_Corrected_Overall_Rate))
#### Watterson's Analysis ####
subset_data <- complete_data %>% filter(Wattersons_Corrected_Overall_Rate != "#DIV/0!") %>% mutate(Log_Wattersons_Corrected_Overall_Rate = log10(as.numeric(Wattersons_Corrected_Overall_Rate))) # Keep only Watterson's data which has values
#### Watterson's Analysis ####
subset_data <- complete_data %>% filter(Wattersons_Corrected_Overall_Rate != "#DIV/0!") %>% mutate(Log_Wattersons_Corrected_Overall_Rate = log10(as.numeric(Wattersons_Corrected_Overall_Rate))) # Keep only Watterson's data which has values
two_strain_tree <- keep.tip(two_strain_tree, subset_data$Species[subset_data$Species %in% two_strain_tree$tip.label]) # Subset the tree to the species present in the data
subset_data = subset_data[subset_data$Species %in% two_strain_tree$tip.label, ] # Subset the data to the species in the tree for redundancy
subset_data$Log_Wattersons_Corrected_Overall_Rate <- as.numeric(subset_data$Log_Wattersons_Corrected_Overall_Rate) # Make sure Watterson's is numeric
rownames(subset_data) = subset_data$Species # Set rownames for reordering to phylogeny
reordered_subset_data <- ReorderData(two_strain_tree, subset_data, taxa.names="row names") # Reorder the data to be the same as the order in the phylogeny; 'row names' reflects the where the species names are
reordered_subset_data$Log_Wattersons_Corrected_Overall_Rate <- as.numeric(reordered_subset_data$Log_Wattersons_Corrected_Overall_Rate) # Keep it numeric
genes = names(subset_data[4:14]) # names of genes we're looking at
results_watterson <- data.frame(gene = character(), lambda = numeric(), linear_AIC = numeric(), pglmm_AIC = numeric(), linear_p_value = numeric(), pglmm_p_value = numeric(), stringsAsFactors = FALSE) # An empty data frame to store outputs
for (gene in genes) {
gene_data <- reordered_subset_data[[gene]]  # Extract the column corresponding to the current gene
linear_model <- lm(Log_Wattersons_Corrected_Overall_Rate ~ gene_data, data = reordered_subset_data)
residuals_test <- residuals(linear_model)  # Get residuals and compute lambda
estimated_lambda <- phylosig(two_strain_tree, residuals_test, method = "lambda")[[1]]
# Linear model statistics
linear_AIC <- AIC(linear_model)
linear_p_value <- coef(summary(linear_model))[8]
# Add linear model results to the table
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "linear", AIC = linear_AIC, p_value = linear_p_value, stringsAsFactors = FALSE))
# Fit PGLMM model
pglmm_model <- pglmm(Log_Wattersons_Corrected_Overall_Rate ~ gene_data + (1 | Species), data = reordered_subset_data, family = "gaussian", cov_ranef = list(Species = gc_tree), REML = FALSE)
pglmm_AIC <- pglmm_model$AIC
pglmm_p_value <- pglmm_model$B.pvalue[[2]]
# Add PGLMM model results to the table
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "pglmm", AIC = pglmm_AIC, p_value = pglmm_p_value, stringsAsFactors = FALSE))
# Adaptive lambda starting value search
if (estimated_lambda <= 0.5) {
search_lambdas <- seq(0, 1, by = 0.1)
} else {
search_lambdas <- rev(seq(0, 1, by = 0.1))
}
# Fit models with different correlation structures and their null models
for (lambda_starting in search_lambdas) {
pagel_model <- tryCatch({    # Try corPagel
gls(Log_Wattersons_Corrected_Overall_Rate ~ gene_data, data = reordered_subset_data, correlation = corPagel(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
pagel_null_model <- tryCatch({    # Try null model with corPagel
gls(Log_Wattersons_Corrected_Overall_Rate ~ 1, data = reordered_subset_data, correlation = corPagel(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
if (!is.null(pagel_model)) {
pagel_AIC <- AIC(pagel_model)
pagel_p_value <- coef(summary(pagel_model))[8]
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "pagel", AIC = pagel_AIC, p_value = pagel_p_value, stringsAsFactors = FALSE))
}
if (!is.null(pagel_null_model)) {
pagel_null_AIC <- AIC(pagel_null_model)
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "pagel_null", AIC = pagel_null_AIC, p_value = NA, stringsAsFactors = FALSE))
break
}
}
for (lambda_starting in search_lambdas) {
blomberg_model <- tryCatch({    # Try corBlomberg
gls(Log_Wattersons_Corrected_Overall_Rate ~ gene_data, data = reordered_subset_data, correlation = corBlomberg(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
blomberg_null_model <- tryCatch({    # Try null model with corBlomberg
gls(Log_Wattersons_Corrected_Overall_Rate ~ 1, data = reordered_subset_data, correlation = corBlomberg(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
if (!is.null(blomberg_model)) {
blomberg_AIC <- AIC(blomberg_model)
blomberg_p_value <- coef(summary(blomberg_model))[8]
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "blomberg", AIC = blomberg_AIC, p_value = blomberg_p_value, stringsAsFactors = FALSE))
}
if (!is.null(blomberg_null_model)) {
blomberg_null_AIC <- AIC(blomberg_null_model)
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "blomberg_null", AIC = blomberg_null_AIC, p_value = NA, stringsAsFactors = FALSE))
break
}
}
for (lambda_starting in search_lambdas) {
brownian_model <- tryCatch({    # Try corBrownian
gls(Log_Wattersons_Corrected_Overall_Rate ~ gene_data, data = reordered_subset_data, correlation = corBrownian(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
brownian_null_model <- tryCatch({    # Try null model with corBrownian
gls(Log_Wattersons_Corrected_Overall_Rate ~ 1, data = reordered_subset_data, correlation = corBrownian(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
if (!is.null(brownian_model)) {
brownian_AIC <- AIC(brownian_model)
brownian_p_value <- coef(summary(brownian_model))[8]
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "brownian", AIC = brownian_AIC, p_value = brownian_p_value, stringsAsFactors = FALSE))
}
if (!is.null(brownian_null_model)) {
brownian_null_AIC <- AIC(brownian_null_model)
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "brownian_null", AIC = brownian_null_AIC, p_value = NA, stringsAsFactors = FALSE))
break
}
}
for (lambda_starting in search_lambdas) {
martins_model <- tryCatch({    # Try corMartins
gls(Log_Wattersons_Corrected_Overall_Rate ~ gene_data, data = reordered_subset_data, correlation = corMartins(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
martins_null_model <- tryCatch({    # Try null model with corMartins
gls(Log_Wattersons_Corrected_Overall_Rate ~ 1, data = reordered_subset_data, correlation = corMartins(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
if (!is.null(martins_model)) {
martins_AIC <- AIC(martins_model)
martins_p_value <- coef(summary(martins_model))[8]
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "martins", AIC = martins_AIC, p_value = martins_p_value, stringsAsFactors = FALSE))
}
if (!is.null(martins_null_model)) {
martins_null_AIC <- AIC(martins_null_model)
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "martins_null", AIC = martins_null_AIC, p_value = NA, stringsAsFactors = FALSE))
break
}
}
for (lambda_starting in search_lambdas) {
grafen_model <- tryCatch({    # Try corGrafen
gls(Log_Wattersons_Corrected_Overall_Rate ~ gene_data, data = reordered_subset_data, correlation = corGrafen(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
grafen_null_model <- tryCatch({    # Try null model with corGrafen
gls(Log_Wattersons_Corrected_Overall_Rate ~ 1, data = reordered_subset_data, correlation = corGrafen(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
if (!is.null(grafen_model)) {
grafen_AIC <- AIC(grafen_model)
grafen_p_value <- coef(summary(grafen_model))[8]
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "grafen", AIC = grafen_AIC, p_value = grafen_p_value, stringsAsFactors = FALSE))
}
if (!is.null(grafen_null_model)) {
grafen_null_AIC <- AIC(grafen_null_model)
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "grafen_null", AIC = grafen_null_AIC, p_value = NA, stringsAsFactors = FALSE))
break
}
}
}
cat("The models with the best fits for log(Watterson's Diversity) are:\n"); data.frame(results_watterson %>% group_by(gene) %>% slice(which.min(AIC)) %>% select(gene, lambda, model, AIC, p_value))
lambda <- phylosig(two_strain_tree, residuals(lm(Log_Wattersons_Corrected_Overall_Rate ~ reordered_subset_data[[gene]], data = reordered_subset_data)), method = "lambda")[[1]]
lambda
gene
summary_table_wattersons = data.frame(gene = character(), lambda = numeric(), Mean_with_Gene = character(), Mean_without_Gene = numeric(), Ratio_w_wo = numeric(), stringsAsFactors = FALSE)
for(gene in genes_tvts){
lambda <- phylosig(two_strain_tree, residuals(lm(Log_Wattersons_Corrected_Overall_Rate ~ reordered_subset_data[[gene]], data = reordered_subset_data)), method = "lambda")[[1]]
Mean_with_Gene = mean(reordered_subset_data$Log_Wattersons_Corrected_Overall_Rate[reordered_subset_data[[gene]]==1])
Mean_without_Gene = mean(reordered_subset_data$Log_Wattersons_Corrected_Overall_Rate[reordered_subset_data[[gene]]==0])
Ratio_w_wo = sum(reordered_subset_data[[gene]] == 0, na.rm = TRUE) / sum(reordered_subset_data[[gene]] == 1, na.rm = TRUE)
summary_table_tvts = rbind(summary_table_tvts, data.frame(gene = gene, lambda = lambda, Mean_with_Gene = Mean_with_Gene, Mean_without_Gene = Mean_without_Gene, Ratio_w_wo = Ratio_w_wo))
}
cat("The summary table for log(Ts:Tv) is:\n"); print(summary_table_tvts)
summary_table_wattersons = data.frame(gene = character(), lambda = numeric(), Mean_with_Gene = numeric(), SE_with_Gene = numeric(), Mean_without_Gene = numeric(), SE_without_Gene = numeric(), Ratio_w_wo = numeric(), stringsAsFactors = FALSE)
for(gene in genes_tvts){
lambda <- phylosig(two_strain_tree, residuals(lm(Log_Wattersons_Corrected_Overall_Rate ~ reordered_subset_data[[gene]], data = reordered_subset_data)), method = "lambda")[[1]]
Mean_with_Gene = mean(reordered_subset_data$Log_Wattersons_Corrected_Overall_Rate[reordered_subset_data[[gene]]==1])
Mean_without_Gene = mean(reordered_subset_data$Log_Wattersons_Corrected_Overall_Rate[reordered_subset_data[[gene]]==0])
SE_with_Gene = sd(reordered_subset_data$Log_Wattersons_Corrected_Overall_Rate[reordered_subset_data[[gene]] == 1], na.rm = TRUE) / sqrt(sum(reordered_subset_data[[gene]] == 1, na.rm = TRUE))
SE_without_Gene = sd(reordered_subset_data$Log_Wattersons_Corrected_Overall_Rate[reordered_subset_data[[gene]] == 0], na.rm = TRUE) / sqrt(sum(reordered_subset_data[[gene]] == 0, na.rm = TRUE))
Ratio_w_wo = sum(reordered_subset_data[[gene]] == 0, na.rm = TRUE) / sum(reordered_subset_data[[gene]] == 1, na.rm = TRUE)
summary_table_tvts = rbind(summary_table_tvts, data.frame(gene = gene, lambda = lambda, Mean_with_Gene = Mean_with_Gene, Mean_without_Gene = Mean_without_Gene, Ratio_w_wo = Ratio_w_wo))
}
summary_table_tvts = data.frame(gene = character(), lambda = numeric(), Mean_with_Gene = numeric(), SE_with_Gene = numeric(), Mean_without_Gene = numeric(), SE_without_Gene = numeric(), Ratio_w_wo = numeric(), stringsAsFactors = FALSE)
for(gene in genes_tvts){
lambda <- phylosig(tvts_tree, residuals(lm(tvts_ratio ~ tvts_subset[[gene]], data = tvts_subset)), method = "lambda")[[1]]
Mean_with_Gene = mean(tvts_subset$tvts_ratio[tvts_subset[[gene]]==1])
Mean_without_Gene = mean(tvts_subset$tvts_ratio[tvts_subset[[gene]]==0])
SE_with_Gene = sd(tvts_subset$tvts_ratio[tvts_subset[[gene]] == 1], na.rm = TRUE) / sqrt(sum(tvts_subset[[gene]] == 1, na.rm = TRUE))
SE_without_Gene = sd(tvts_subset$tvts_ratio[tvts_subset[[gene]] == 0], na.rm = TRUE) / sqrt(sum(tvts_subset[[gene]] == 0, na.rm = TRUE))
Ratio_w_wo = sum(tvts_subset[[gene]] == 0, na.rm = TRUE) / sum(tvts_subset[[gene]] == 1, na.rm = TRUE)
summary_table_tvts = rbind(summary_table_tvts, data.frame(gene = gene, lambda = lambda, Mean_with_Gene = Mean_with_Gene, Mean_without_Gene = Mean_without_Gene, Ratio_w_wo = Ratio_w_wo))
}
summary_table_gc = data.frame(gene = character(), lambda = numeric(), Mean_with_Gene = numeric(), SE_with_Gene = numeric(), Mean_without_Gene = numeric(), SE_without_Gene = numeric(), Ratio_w_wo = numeric(), stringsAsFactors = FALSE)
for(gene in genes_gc){
lambda <- phylosig(gc_tree, residuals(lm(GC_rate ~ gc_subset[[gene]], data = gc_subset)), method = "lambda")[[1]]
Mean_with_Gene = mean(gc_subset$GC_rate[gc_subset[[gene]] == 1], na.rm = TRUE)
Mean_without_Gene = mean(gc_subset$GC_rate[gc_subset[[gene]] == 0], na.rm = TRUE)
SE_with_Gene = sd(gc_subset$GC_rate[gc_subset[[gene]] == 1], na.rm = TRUE) / sqrt(sum(gc_subset[[gene]] == 1, na.rm = TRUE))
SE_without_Gene = sd(gc_subset$GC_rate[gc_subset[[gene]] == 0], na.rm = TRUE) / sqrt(sum(gc_subset[[gene]] == 0, na.rm = TRUE))
Ratio_w_wo = sum(gc_subset[[gene]] == 0, na.rm = TRUE) / sum(gc_subset[[gene]] == 1, na.rm = TRUE)
summary_table_gc = rbind(summary_table_gc, data.frame(gene = gene, lambda = lambda, Mean_with_Gene = Mean_with_Gene, SE_with_Gene = SE_with_Gene, Mean_without_Gene = Mean_without_Gene, SE_without_Gene = SE_without_Gene, Ratio_w_wo = Ratio_w_wo))
}
cat("The models with the best fits for log(Watterson's Diversity) are:\n"); data.frame(results_watterson %>% group_by(gene) %>% slice(which.min(AIC)) %>% select(gene, lambda, model, AIC, p_value))
cat("The summary table for log(Watterson's Diversity) is:\n"); print(summary_table_wattersons)
cat("The models with the best fits for log(Ts:Tv) are:\n"); data.frame(results_tvts_ratio %>% group_by(gene) %>% slice(which.min(AIC)) %>% select(gene, lambda, model, AIC, p_value))
cat("The summary table for log(Ts:Tv) is:\n"); print(summary_table_tvts)
cat("The models with the best fitsfor log(GC > AT) are:\n"); data.frame(results_gc_rate %>% group_by(gene) %>% slice(which.min(AIC)) %>% select(gene, lambda, model, AIC, p_value))
cat("The summary table for log(GC > AT) is:\n"); print(summary_table_gc)
cat("The summary table for log(Watterson's Diversity) is:\n"); print(summary_table_wattersons)
summary_table_wattersons = data.frame(gene = character(), lambda = numeric(), Mean_with_Gene = numeric(), SE_with_Gene = numeric(), Mean_without_Gene = numeric(), SE_without_Gene = numeric(), Ratio_w_wo = numeric(), stringsAsFactors = FALSE)
for(gene in genes_tvts){
lambda <- phylosig(two_strain_tree, residuals(lm(Log_Wattersons_Corrected_Overall_Rate ~ reordered_subset_data[[gene]], data = reordered_subset_data)), method = "lambda")[[1]]
Mean_with_Gene = mean(reordered_subset_data$Log_Wattersons_Corrected_Overall_Rate[reordered_subset_data[[gene]]==1])
Mean_without_Gene = mean(reordered_subset_data$Log_Wattersons_Corrected_Overall_Rate[reordered_subset_data[[gene]]==0])
SE_with_Gene = sd(reordered_subset_data$Log_Wattersons_Corrected_Overall_Rate[reordered_subset_data[[gene]] == 1], na.rm = TRUE) / sqrt(sum(reordered_subset_data[[gene]] == 1, na.rm = TRUE))
SE_without_Gene = sd(reordered_subset_data$Log_Wattersons_Corrected_Overall_Rate[reordered_subset_data[[gene]] == 0], na.rm = TRUE) / sqrt(sum(reordered_subset_data[[gene]] == 0, na.rm = TRUE))
Ratio_w_wo = sum(reordered_subset_data[[gene]] == 0, na.rm = TRUE) / sum(reordered_subset_data[[gene]] == 1, na.rm = TRUE)
summary_table_wattersons = rbind(summary_table_wattersons, data.frame(gene = gene, lambda = lambda, Mean_with_Gene = Mean_with_Gene, Mean_without_Gene = Mean_without_Gene, Ratio_w_wo = Ratio_w_wo))
}
cat("The models with the best fits for log(Watterson's Diversity) are:\n"); data.frame(results_watterson %>% group_by(gene) %>% slice(which.min(AIC)) %>% select(gene, lambda, model, AIC, p_value))
cat("The summary table for log(Watterson's Diversity) is:\n"); print(summary_table_wattersons)
cat("The models with the best fits for log(Ts:Tv) are:\n"); data.frame(results_tvts_ratio %>% group_by(gene) %>% slice(which.min(AIC)) %>% select(gene, lambda, model, AIC, p_value))
cat("The summary table for log(Ts:Tv) is:\n"); print(summary_table_tvts)
cat("The models with the best fitsfor log(GC > AT) are:\n"); data.frame(results_gc_rate %>% group_by(gene) %>% slice(which.min(AIC)) %>% select(gene, lambda, model, AIC, p_value))
cat("The summary table for log(GC > AT) is:\n"); print(summary_table_gc)
#### Watterson's Analysis ####
subset_data <- complete_data %>% filter(Wattersons_Corrected_Overall_Rate != "#DIV/0!") %>% mutate(Log_Wattersons_Corrected_Overall_Rate = log10(as.numeric(Wattersons_Corrected_Overall_Rate))) # Keep only Watterson's data which has values
two_strain_tree <- keep.tip(two_strain_tree, subset_data$Species[subset_data$Species %in% two_strain_tree$tip.label]) # Subset the tree to the species present in the data
subset_data = subset_data[subset_data$Species %in% two_strain_tree$tip.label, ] # Subset the data to the species in the tree for redundancy
subset_data$Log_Wattersons_Corrected_Overall_Rate <- as.numeric(subset_data$Log_Wattersons_Corrected_Overall_Rate) # Make sure Watterson's is numeric
rownames(subset_data) = subset_data$Species # Set rownames for reordering to phylogeny
reordered_subset_data <- ReorderData(two_strain_tree, subset_data, taxa.names="row names") # Reorder the data to be the same as the order in the phylogeny; 'row names' reflects the where the species names are
reordered_subset_data$Log_Wattersons_Corrected_Overall_Rate <- as.numeric(reordered_subset_data$Log_Wattersons_Corrected_Overall_Rate) # Keep it numeric
genes = names(subset_data[4:14]) # names of genes we're looking at
results_watterson <- data.frame(gene = character(), lambda = numeric(), linear_AIC = numeric(), pglmm_AIC = numeric(), linear_p_value = numeric(), pglmm_p_value = numeric(), stringsAsFactors = FALSE) # An empty data frame to store outputs
for (gene in genes) {
gene_data <- reordered_subset_data[[gene]]  # Extract the column corresponding to the current gene
linear_model <- lm(Log_Wattersons_Corrected_Overall_Rate ~ gene_data, data = reordered_subset_data)
residuals_test <- residuals(linear_model)  # Get residuals and compute lambda
estimated_lambda <- phylosig(two_strain_tree, residuals_test, method = "lambda")[[1]]
# Linear model statistics
linear_AIC <- AIC(linear_model)
linear_p_value <- coef(summary(linear_model))[8]
# Add linear model results to the table
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "linear", AIC = linear_AIC, p_value = linear_p_value, stringsAsFactors = FALSE))
# Linear Null
linear_model <- lm(Log_Wattersons_Corrected_Overall_Rate ~ 1, data = reordered_subset_data)
linear_null_AIC <- AIC(linear_null_model)
linear_null_p_value <- coef(summary(linear_null_model))[8]
# Add linear null model results to the table
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "linear_null", AIC = linear_null_AIC, p_value = NA, stringsAsFactors = FALSE))
# Fit PGLMM model
pglmm_model <- pglmm(Log_Wattersons_Corrected_Overall_Rate ~ gene_data + (1 | Species), data = reordered_subset_data, family = "gaussian", cov_ranef = list(Species = gc_tree), REML = FALSE)
pglmm_AIC <- pglmm_model$AIC
pglmm_p_value <- pglmm_model$B.pvalue[[2]]
# Add PGLMM model results to the table
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "pglmm", AIC = pglmm_AIC, p_value = pglmm_p_value, stringsAsFactors = FALSE))
# Adaptive lambda starting value search
if (estimated_lambda <= 0.5) {
search_lambdas <- seq(0, 1, by = 0.1)
} else {
search_lambdas <- rev(seq(0, 1, by = 0.1))
}
# Fit models with different correlation structures and their null models
for (lambda_starting in search_lambdas) {
pagel_model <- tryCatch({    # Try corPagel
gls(Log_Wattersons_Corrected_Overall_Rate ~ gene_data, data = reordered_subset_data, correlation = corPagel(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
pagel_null_model <- tryCatch({    # Try null model with corPagel
gls(Log_Wattersons_Corrected_Overall_Rate ~ 1, data = reordered_subset_data, correlation = corPagel(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
if (!is.null(pagel_model)) {
pagel_AIC <- AIC(pagel_model)
pagel_p_value <- coef(summary(pagel_model))[8]
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "pagel", AIC = pagel_AIC, p_value = pagel_p_value, stringsAsFactors = FALSE))
}
if (!is.null(pagel_null_model)) {
pagel_null_AIC <- AIC(pagel_null_model)
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "pagel_null", AIC = pagel_null_AIC, p_value = NA, stringsAsFactors = FALSE))
break
}
}
for (lambda_starting in search_lambdas) {
blomberg_model <- tryCatch({    # Try corBlomberg
gls(Log_Wattersons_Corrected_Overall_Rate ~ gene_data, data = reordered_subset_data, correlation = corBlomberg(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
blomberg_null_model <- tryCatch({    # Try null model with corBlomberg
gls(Log_Wattersons_Corrected_Overall_Rate ~ 1, data = reordered_subset_data, correlation = corBlomberg(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
if (!is.null(blomberg_model)) {
blomberg_AIC <- AIC(blomberg_model)
blomberg_p_value <- coef(summary(blomberg_model))[8]
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "blomberg", AIC = blomberg_AIC, p_value = blomberg_p_value, stringsAsFactors = FALSE))
}
if (!is.null(blomberg_null_model)) {
blomberg_null_AIC <- AIC(blomberg_null_model)
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "blomberg_null", AIC = blomberg_null_AIC, p_value = NA, stringsAsFactors = FALSE))
break
}
}
for (lambda_starting in search_lambdas) {
brownian_model <- tryCatch({    # Try corBrownian
gls(Log_Wattersons_Corrected_Overall_Rate ~ gene_data, data = reordered_subset_data, correlation = corBrownian(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
brownian_null_model <- tryCatch({    # Try null model with corBrownian
gls(Log_Wattersons_Corrected_Overall_Rate ~ 1, data = reordered_subset_data, correlation = corBrownian(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
if (!is.null(brownian_model)) {
brownian_AIC <- AIC(brownian_model)
brownian_p_value <- coef(summary(brownian_model))[8]
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "brownian", AIC = brownian_AIC, p_value = brownian_p_value, stringsAsFactors = FALSE))
}
if (!is.null(brownian_null_model)) {
brownian_null_AIC <- AIC(brownian_null_model)
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "brownian_null", AIC = brownian_null_AIC, p_value = NA, stringsAsFactors = FALSE))
break
}
}
for (lambda_starting in search_lambdas) {
martins_model <- tryCatch({    # Try corMartins
gls(Log_Wattersons_Corrected_Overall_Rate ~ gene_data, data = reordered_subset_data, correlation = corMartins(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
martins_null_model <- tryCatch({    # Try null model with corMartins
gls(Log_Wattersons_Corrected_Overall_Rate ~ 1, data = reordered_subset_data, correlation = corMartins(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
if (!is.null(martins_model)) {
martins_AIC <- AIC(martins_model)
martins_p_value <- coef(summary(martins_model))[8]
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "martins", AIC = martins_AIC, p_value = martins_p_value, stringsAsFactors = FALSE))
}
if (!is.null(martins_null_model)) {
martins_null_AIC <- AIC(martins_null_model)
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "martins_null", AIC = martins_null_AIC, p_value = NA, stringsAsFactors = FALSE))
break
}
}
for (lambda_starting in search_lambdas) {
grafen_model <- tryCatch({    # Try corGrafen
gls(Log_Wattersons_Corrected_Overall_Rate ~ gene_data, data = reordered_subset_data, correlation = corGrafen(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
grafen_null_model <- tryCatch({    # Try null model with corGrafen
gls(Log_Wattersons_Corrected_Overall_Rate ~ 1, data = reordered_subset_data, correlation = corGrafen(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
if (!is.null(grafen_model)) {
grafen_AIC <- AIC(grafen_model)
grafen_p_value <- coef(summary(grafen_model))[8]
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "grafen", AIC = grafen_AIC, p_value = grafen_p_value, stringsAsFactors = FALSE))
}
if (!is.null(grafen_null_model)) {
grafen_null_AIC <- AIC(grafen_null_model)
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "grafen_null", AIC = grafen_null_AIC, p_value = NA, stringsAsFactors = FALSE))
break
}
}
}
for (gene in genes) {
gene_data <- reordered_subset_data[[gene]]  # Extract the column corresponding to the current gene
linear_model <- lm(Log_Wattersons_Corrected_Overall_Rate ~ gene_data, data = reordered_subset_data)
residuals_test <- residuals(linear_model)  # Get residuals and compute lambda
estimated_lambda <- phylosig(two_strain_tree, residuals_test, method = "lambda")[[1]]
# Linear model statistics
linear_AIC <- AIC(linear_model)
linear_p_value <- coef(summary(linear_model))[8]
# Add linear model results to the table
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "linear", AIC = linear_AIC, p_value = linear_p_value, stringsAsFactors = FALSE))
# Linear Null
linear_null_model <- lm(Log_Wattersons_Corrected_Overall_Rate ~ 1, data = reordered_subset_data)
linear_null_AIC <- AIC(linear_null_model)
linear_null_p_value <- coef(summary(linear_null_model))[8]
# Add linear null model results to the table
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "linear_null", AIC = linear_null_AIC, p_value = NA, stringsAsFactors = FALSE))
# Fit PGLMM model
pglmm_model <- pglmm(Log_Wattersons_Corrected_Overall_Rate ~ gene_data + (1 | Species), data = reordered_subset_data, family = "gaussian", cov_ranef = list(Species = gc_tree), REML = FALSE)
pglmm_AIC <- pglmm_model$AIC
pglmm_p_value <- pglmm_model$B.pvalue[[2]]
# Add PGLMM model results to the table
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "pglmm", AIC = pglmm_AIC, p_value = pglmm_p_value, stringsAsFactors = FALSE))
# Adaptive lambda starting value search
if (estimated_lambda <= 0.5) {
search_lambdas <- seq(0, 1, by = 0.1)
} else {
search_lambdas <- rev(seq(0, 1, by = 0.1))
}
# Fit models with different correlation structures and their null models
for (lambda_starting in search_lambdas) {
pagel_model <- tryCatch({    # Try corPagel
gls(Log_Wattersons_Corrected_Overall_Rate ~ gene_data, data = reordered_subset_data, correlation = corPagel(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
pagel_null_model <- tryCatch({    # Try null model with corPagel
gls(Log_Wattersons_Corrected_Overall_Rate ~ 1, data = reordered_subset_data, correlation = corPagel(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
if (!is.null(pagel_model)) {
pagel_AIC <- AIC(pagel_model)
pagel_p_value <- coef(summary(pagel_model))[8]
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "pagel", AIC = pagel_AIC, p_value = pagel_p_value, stringsAsFactors = FALSE))
}
if (!is.null(pagel_null_model)) {
pagel_null_AIC <- AIC(pagel_null_model)
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "pagel_null", AIC = pagel_null_AIC, p_value = NA, stringsAsFactors = FALSE))
break
}
}
for (lambda_starting in search_lambdas) {
blomberg_model <- tryCatch({    # Try corBlomberg
gls(Log_Wattersons_Corrected_Overall_Rate ~ gene_data, data = reordered_subset_data, correlation = corBlomberg(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
blomberg_null_model <- tryCatch({    # Try null model with corBlomberg
gls(Log_Wattersons_Corrected_Overall_Rate ~ 1, data = reordered_subset_data, correlation = corBlomberg(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
if (!is.null(blomberg_model)) {
blomberg_AIC <- AIC(blomberg_model)
blomberg_p_value <- coef(summary(blomberg_model))[8]
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "blomberg", AIC = blomberg_AIC, p_value = blomberg_p_value, stringsAsFactors = FALSE))
}
if (!is.null(blomberg_null_model)) {
blomberg_null_AIC <- AIC(blomberg_null_model)
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "blomberg_null", AIC = blomberg_null_AIC, p_value = NA, stringsAsFactors = FALSE))
break
}
}
for (lambda_starting in search_lambdas) {
brownian_model <- tryCatch({    # Try corBrownian
gls(Log_Wattersons_Corrected_Overall_Rate ~ gene_data, data = reordered_subset_data, correlation = corBrownian(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
brownian_null_model <- tryCatch({    # Try null model with corBrownian
gls(Log_Wattersons_Corrected_Overall_Rate ~ 1, data = reordered_subset_data, correlation = corBrownian(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
if (!is.null(brownian_model)) {
brownian_AIC <- AIC(brownian_model)
brownian_p_value <- coef(summary(brownian_model))[8]
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "brownian", AIC = brownian_AIC, p_value = brownian_p_value, stringsAsFactors = FALSE))
}
if (!is.null(brownian_null_model)) {
brownian_null_AIC <- AIC(brownian_null_model)
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "brownian_null", AIC = brownian_null_AIC, p_value = NA, stringsAsFactors = FALSE))
break
}
}
for (lambda_starting in search_lambdas) {
martins_model <- tryCatch({    # Try corMartins
gls(Log_Wattersons_Corrected_Overall_Rate ~ gene_data, data = reordered_subset_data, correlation = corMartins(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
martins_null_model <- tryCatch({    # Try null model with corMartins
gls(Log_Wattersons_Corrected_Overall_Rate ~ 1, data = reordered_subset_data, correlation = corMartins(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
if (!is.null(martins_model)) {
martins_AIC <- AIC(martins_model)
martins_p_value <- coef(summary(martins_model))[8]
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "martins", AIC = martins_AIC, p_value = martins_p_value, stringsAsFactors = FALSE))
}
if (!is.null(martins_null_model)) {
martins_null_AIC <- AIC(martins_null_model)
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "martins_null", AIC = martins_null_AIC, p_value = NA, stringsAsFactors = FALSE))
break
}
}
for (lambda_starting in search_lambdas) {
grafen_model <- tryCatch({    # Try corGrafen
gls(Log_Wattersons_Corrected_Overall_Rate ~ gene_data, data = reordered_subset_data, correlation = corGrafen(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
grafen_null_model <- tryCatch({    # Try null model with corGrafen
gls(Log_Wattersons_Corrected_Overall_Rate ~ 1, data = reordered_subset_data, correlation = corGrafen(lambda_starting, two_strain_tree, form = ~Species), method = "ML")
}, error = function(e) NULL)
if (!is.null(grafen_model)) {
grafen_AIC <- AIC(grafen_model)
grafen_p_value <- coef(summary(grafen_model))[8]
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "grafen", AIC = grafen_AIC, p_value = grafen_p_value, stringsAsFactors = FALSE))
}
if (!is.null(grafen_null_model)) {
grafen_null_AIC <- AIC(grafen_null_model)
results_watterson <- rbind(results_watterson, data.frame(gene = gene, lambda = estimated_lambda, model = "grafen_null", AIC = grafen_null_AIC, p_value = NA, stringsAsFactors = FALSE))
break
}
}
}
source("~/Documents/Mutation_Rate/modified_phylo_plot_w_enz_transitions.R", echo=TRUE)
source("~/Documents/Mutation_Rate/modified_phylo_plot_w_enz_transitions.R", echo=TRUE)
source("~/Documents/Mutation_Rate/modified_phylo_plot_w_enz_transitions.R", echo=TRUE)
cat("\n For all AICs that have not been included in the above summaries, look at the files: results_watterson, results_gc_rate, results_tvts_ratio")
cat("The models with the best fits for log(Watterson's Diversity) are:\n"); data.frame(results_watterson %>% group_by(gene) %>% slice(which.min(AIC)) %>% select(gene, lambda, model, AIC, p_value))
cat("The summary table for log(Watterson's Diversity) is:\n"); print(summary_table_wattersons)
cat("The summary table for log(Ts:Tv) is:\n"); print(summary_table_tvts)
cat("The summary table for log(GC > AT) is:\n"); print(summary_table_gc)
cat("The summary table for log(Watterson's Diversity) is:\n"); print(summary_table_wattersons)
